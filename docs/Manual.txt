***  Pawmoo 使い方説明書

1. はじめに
  Pawmoo は Controller-View-Model のようなWEBアプリケーションを素早く作成するためのオブ
  ジェクト指向型のミニ・フレームワークです。
  M-V-Cに相当する各ファイルを「モジュール」というフォルダ単位で管理できるのでファイル間の
  見通しが良く、機能追加や修正の際にも修正漏れやバグ発生を抑えられます。
  ※「Pawmoo」って何？
    「Object-Oriented-Module Web Application Platform」の頭文字を逆から読むと...

1.1 特徴
  ビューテンプレートは一般的なフレームワークで採用されているSmartyやTwig などのテンプレート
  エンジンを使わず、PHPの連想配列を利用した独自の「セクションテンプレート」と呼ぶ形式を採用
  しています。構文は、HTMLのタグ構造に近い記述形式になっており、HTMLからの移行が簡単にでき、
  またレイアウト全体が見渡しやすいので、デザイン修正や保守が簡単にできます。
  さらにスタイルシートやjavascript、言語リソースにもセクション形式を採用しています。

  フォルダ構造も他のフレームワークと異なり「モジュール」という考え方に基づいて、MVC各クラス
  ファイルをひとまとめにした「モジュールフォルダ」で管理しています。
  機能単位の関連ファイルがひとつのフォルダにまとまっているので、デバッグやテストが容易になる
  だけでなく、間違って他のクラスファイルを書き換えてしまう誤操作を防止できます。

  リクエストURIとモジュールの関係(ルーティング)
    http://localhost/pawmoo/help/index/view/100/20
    ~~~~~~~~~~~~~~~~~~~~~~ ~~~~ ~~~~~ ~~~~ ~~~~~~
    フレームワークフォルダ  ↑ 　↑  　↑　　↑
      　　　　　　　　　　　│ 　│  　│   メソッドへのパラメータ
　　　　　　　　　　　　　　│ 　│   メソッド名
　　　　　　　　　　　　　　│  モジュール名(コントローラー)
　　　　　　　　　　　　　　アプリ名

1.2 フォルダ構成

(pawmoo)         フレームワーク本体
  ├ app
  │  ├─ (アプリ1)
  │  │   ├── Config            アプリケーション設定ファイルフォルダ
  │  │   ├── common            共有ライブラリの格納フォルダ
  │  │   ├── Models            コントローラを持たないモデルクラスのフォルダ
  │  │   ├── extends           モジュール共通の拡張クラス定義
  │  │   ├── error             エラーページ等の単一ページ出力用
  │  │   ├─┬ modules           アプリケーションモジュールフォルダ
  │  │   │  └─┬ Index         モジュール名フォルダ
  │  │   │      ├── View      モジュール固有ビューのテンプレート
  │  │   │      └─┬ res       モジュール有リソースフォルダ
  │  │   │          ├── css   スタイルシート
  │  │   │          └── js    javascript
  │  │   ├─┬ View              アプリケーション共通ビューのテンプレートフォルダ
  │  │   │  ├── lang          言語リソースフォルダ
  │  │   │  └─┬ res           リソースフォルダ
  │  │   │      ├── css       スタイルシートテンプレート
  │  │   │      └── js        Javascriptテンプレート
  │  │   └─┬ webroot           アプリケーション共通の静的リソース
  │  │       ├── cssimg          CSS内で使用する画像
  │  │       ├── css             スタイルシート
  │  │       ├── images          イメージファイル
  │  │       └── js              Javascript
  │  ├─ (アプリ2)
  │  │     .....
  │   ........
  ├ Core                    フレームワークフォルダ
  │  ├── Base              フレームワーク基底クラス
  │  ├── Class             フレームワーク汎用クラス
  │  ├── Common            フレームワーク共有関数ファイル
  │  ├── Config            フレームワーク設定フォルダ
  │  ├── error             エラーページ等の単一ページ出力用
  │  ├── handler           データベースドライバークラス
  │  └─┬ Template          フレームワークテンプレート
  │      ├── lang            フレームワーク言語リソース
  │      ├── View            ビューテンプレート
  │      ├─┬ res             リソースフォルダ
  │      │  ├── css           スタイルシート
  │      │  └── js            javascript
  │      └─┬ webroot         テンプレート共通の静的リソース
  │          ├── cssimg        CSS内で使用する画像
  │          ├── css           スタイルシート
  │          ├── images        イメージファイル
  │          └── js            Javascript
  │
  └ vendor                  ベンダーライブラリフォルダ
      ├─ vendor               PHPライブラリフォルダ
      │   ├ PHPExcel            PHPExcelのライブラリ
      │   ├ mpdf70              PDF作成ライブラリ
      │   ├ ,,,                 その他のライブラリ
      │   ,,,
      └ webroot              外部リソース
          ├─ css                スタイルシート
          ├─ images             イメージファイル
          └─ js                 Javascript

  モジュールフォルダの中に「アプリ名」と同じフォルダを作成すると、そのモジュールは特別な
  意味をもち、コントローラーが省略されたときのトップフォルダを表示するときの処理モジュール
  として呼び出されます。

1.3 対応データベース

　本ライブラリは初期状態で、SQLite3, PostgreSQL, MariaDB(MySQL)のデータベースドライバが
　組み込んであります。
　データベースドライバを追加することで新しいデータベース利用が可能になります。
　ドライバは Core/Handler フォルダに格納しますが、データベース接続パラメータは
  アプリケーション固有になるので app/Config に定義します。
　SLite3やPostgreSQL, MariaDBなどのSQLベースのデータベース操作に必要なSQLの基本
  クラスはSQLHandlerクラスに実装しています。
　データベース固有のSQL構文が必要な処理は、それぞれのドライバでoverrideしてください。

1.4 フレームワーク・クラス

  PawmooではMVCに相当する基底クラスオブジェクトを継承し機能を実装します。
  アプリケーションによっては基底クラスのメソッドで不足する機能を、
  app拡張クラスフォルダ(app/extends)に、独自の継承クラスを作り込むことで、
  特定アプリ専用の基底クラスに拡張することができます。

■ファイルのオートロード
  アプリケーションフォルダ内の common フォルダはモジュールを読み込む前に全てのファイルを
  include します。
  デバッグ用の関数や、共通のライブラリ関数などはここに定義しておきます。
  クラスファイルを作成する場合は、クラス名.php というファイル名で「Class」または「extends」
  「Models」「Models/Asst」「Models/Misc」の各フォルダに格納された定義ファイルを
  オートローダーが自動的にを読み込むようになっています。
  またAppObjectには未定義プロパティを Model クラスとしてオートロードする機能を実装してあります。
  オートローダーの探索フォルダに加え「modules」下にある各モジュールの Model ファイルが利用できます。
  プロパティ名が「...Controller」の時には、別のモジュールコントローラー一式をオートロードします。
  独自クラスをオートロードするときはプロパティ名を「...Class」とします。
    ex.
      Controller->Data            DataModelクラスをオートロードしてオブジェクト生成
      Controller->DataModel       同上
      Controller->DataController  DataController,DataView,DataModel をオートロードしてオブジェクト生成
      Controller->DataClass       独自クラス(DataClass.php)をオートロードしてオブジェクト生成

  ＊モジュールの動的クラスはアプリケーション内で全て共有されるようになりました。(0.52.0以降)

■ クラス相関図
  Controller --+--- Model <-------+
               |      ↑          |
               +---- View -----> Helper ( -> PHPExcel/mPDF )

    AppController                   URLリクエストの処理
        AppModel(*)                   データベース検索、データセット
            AppModel                    リレーション参照用のサブモデル(動的生成)
        AppView                       レイアウト制御
            AppModel(*)                 AppControllerのModelリファレンス
            AppHelper                   HTML整形
                AppModel(*)               AppControllerのModelリファレンス

  クラス継承は各モデルクラスとも
      基底クラス → [ 拡張クラス → ]  モジュールクラス
  となっています。拡張クラス(extends)は使用しない場合もあります。

  この継承順をもとにフレームワークの基底クラスを拡張する手順を紹介します。
  ◇ フレームワーク拡張ステップ
    ・アプリケーション個別モジュールの開発を行う
    ・モジュール間で共通のメソッドが出てきた場合、extendsフォルダに拡張クラスとして再定義しクラス継承する
    ・拡張クラスが他のアプリケーションでも再利用可能なメソッドであればフレームワークの基底クラスに再定義する

　同様にテンプレートリソースの拡張ステップも紹介します。
  ◇ リソース拡張ステップ
    ・個別モジュールで使用するリソースをモジュールリソースフォルダに格納する
    ・モジュール間で共有できるリソースについては、共通ビューのリソースフォルダに格納する
    ・アプリケーションに依存しないリソースについてはフレームワークフォルダに格納する

1.5 多言語対応
  本フレームワークでは多言語の扱いに複数の仕組みを用意しています。

1.5.1 ショートテキスト
  メニューやラベルなど、短いテキストを多言語化するには言語クラスを使います。
  翻訳されたテキストは言語リソーステンプレートに記述し、参照する時は言語クラスのメソッド
  またはビューテンプレート内で言語リソース変数として参照します。
  言語クラスへのアクセスは最上位クラスのAppObjectにカプセル化してあります。
  翻訳テキストにアクセスするにはメソッドまたは言語変数として参照します。
      $this->_(言語識別子);       // メソッドによる参照
      ${#言語識別子}              // テンプレート内での言語変数として参照
  言語識別子の詳細は後述の「言語リソーステンプレート」を参照してください。

1.5.2 レコードフィールド
  データベースに格納されるフィールド値を多言語化する場合は、モデルクラスの言語エイリアス
  インターフェースを使用します。
  この機能はあらかじめレコードフィールドにマスターフィールド、言語フィールドを定義しておき、
  接続してきたブラウザの言語仕様などを元に参照するフィールドを自動的に切替える機能です。
  この機能を有効にするにはモデルクラス内のデータベーススキーマ定義に言語フラグを立てておきます。
  また、モデルクラス内のプロパティ(AliasMode)をTRUEにしておきます。(デフォルト値はTRUE)
      static $DatabaseSchema = [
        ...
        'Schema' => [
            'title'    => ['',101],    // 百の位が言語フラグ: 言語が en なら title_en が有効なフィールド名になる
            'contents' => ['',101],

  この仕組みは多言化が必要なフィールド数が少ない場合に有効です。
  言語フィールド名はDBハンドラー内部で自動変換されます。そのためアプリケーションは言語フィールドを意識せずに
  記述することができます。
  レコード全体が翻訳対照になるような場合は次項のテーブルスイッチを使います。

1.5.3 テーブルスイッチ
  テーブルそのものを言語別に用意してデータベース操作を行う仕組みです。
  それぞれのテーブル構造は同一である必要があります。
  どの言語テーブルに接続するかはモデルクラスのDataTableプロパティの代わりにテーブルスイッチプロパティで定義します。
      static $DatabaseSchema = [
        ...
        'ModelTables' => [
          '*'   => 'MyTable',
          'en'  => 'MyTable_en',
        ],
  ＊ は言語識別が一致しなかったときに使われるデフォルトテーブル名を指名します。
  テーブル名は自由に命名できますが、メンテナンスを考慮して同じ名前に言語識別文字列を付加したものを推奨します。

1.5.4 その他
  これまでの仕組みで対応できないものは、アプリケーション独自に多言語化を行ってください。
  その場合、本フレームワークの多言語対応の仕組みを全て無効化して使用します。
  無効化する場合は
    ・言語リソースを定義しない (*.lng を作らない)
    ・スキーマ定義の言語フラグをOFF(百位の値を使用しない)
    ・モデルクラスの ClassInit() メソッド内で AliasMode = FALSE とする
    ・テーブルスイッチを使わずに DataTable プロパティでテーブルを指示する

1.6 ルーティング
  アプリケーションのURIはvendorリソース、静的CSS/JS、画像ファイル以外をすべて
  inde.php へアクセスするように mod_rewrite による書換えを行います。
  index.php ではコントローラー要求と動的CSS/JSを処理します。

  リクエストされたURIは次のように分解し、モジュールコントローラのメソッドを起動します。

  リクエストURIとモジュールの関係(ルーティング)
    http://localhost/pawmoo/help/index/view/filter/100/20
    ~~~~~~~~~~~~~~~~~~~~~~~ ~~~~ ~~~~~ ~~~~ ~~~~~~ ~~~~~~
    フレームワークフォルダ   ↑  　↑   ↑　　↑　  ↑
    　　　　　　　　　　　　 │  　│ 　│    │    メソッドへのパラメータ
    　　　　　　　　　　　　 │  　│ 　│    メソッドのフィルタ処理パラメータ(複数指定可)
　　  　　　　　　　　　　　 │  　│   アクションメソッド名
　　　  　　　　　　　　　　 │    モジュール名(コントローラー)
　　　　　　　　　　　　　　アプリ名

     ルーティング情報は App クラスの静的変数に格納されます。

      App::$AppName           アプリ名
      App::$Controller        コントローラ名
      App::$Method            メソッド名
      App::$MethodExtention   ファイルダイレクト時の拡張子 (※後述)
      App::$Filter            フィルタパス配列の先頭
      App::$Filters[]         フィルタパス配列
      App::$Params[]           数値パラメータパスの配列

    上記のURIでは以下のようになります。
      アプリ名: Help
      コントローラー: Index
      メソッド: View
      拡張子: NULL
      フィルター: filter
      フィルター配列: [ filter ]
      パラメータ配列: [ 100, 20 ]

    アクションメソッド名から数値パスが始まるまでの間をメソッドフィルタ配列として扱います。
    最初の数値パス以降に現れる数字以外の文字列は「パラメータ配列」に格納されます。
    ex. view/filter/100/setup/10
      メソッド: View
      フィルター配列: [ filter ]
      パラメータ配列: [ 100, setup, 10 ]

1.6.1 ファイルダイレクトURI
      URIをファイル名まで指定されたときには、ファイル名部分がメソッド名になり拡張子は
      App::$MethodExtention 変数に格納します。
      パス上のメソッド名以降はフィルタ配列にシフトされます。

       http://localhost/help/index/view/param/1/2/3/list.html
                                                    ^^^^^^^^^
      上記URIの場合、ルーティング情報は次のようになります。

      アプリ名: help
      コントローラー: Index
      メソッド: List
      拡張子: html
      フィルター: view
      フィルター配列: [ view, param ]
      パラメータ: [ 1, 2, 3 ]

    コントローラーが省略された場合、アプリ名をコントローラー名に設定します。

      http://localhost/help/index.php
                          　^^^^^^^^^
      アプリ名: help
      コントローラー: Help
      メソッド: Index
      拡張子: php
      フィルター: NULL
      フィルター配列: [ ]
      パラメータ: [ ]

    ファイル名をメソッドとして扱う対象となる拡張子は次の通りです。
      'html','htm','php','cgi','js','css','inc'
    これ以外の拡張子の時には、通常のパラメータ配列に格納します。
      ex. http://localhost/help/index/view/param/1/2/3/list.doc
            コントローラー: Index
            メソッド: View
            拡張子: 
            フィルター: param
            フィルター配列: [ param ]
            パラメータ: [ 1, 2, 3 , list.doc ]

2. クラス詳細

2.1 コントローラー詳細
　モジュールは必ずコントローラを所有しなければなりません。
　基底クラスの AppController を継承することで、モジュール側の実装は最小限で済みます。
　また基底クラスのアクションメソッドを無効化したり、アクション省略時のデフォルトアクションや
  アクションメソッドの呼出しに別名を定義することもできます。

　基底クラスの AppController は、所属するモジュールのモデル、ビュー(ヘルパー)クラスを生成します。
　ビュークラスは原則基底クラスを使用しますが、モジュール側で拡張することもできます。
　モジュール固有のモデルクラス、ヘルパークラスが無いときは基底クラスを元にクラス生成します。
　モデルクラスが基底クラスで生成されると、ドライバーが未定義のためデータベースが利用できません。

2.2 モデル詳細
　モジュールのモデルクラスは AppModel クラスを継承し、データベースへのアクセスインタフェースを提供します。
　データベースのテーブルやフィールドスキーマを定義し、データの入出力を制御します。
　実際のデータベースへのアクセスはドライバークラスが担当し、モデルクラスはインタフェースの抽象化により
　コントローラーやビューからデータベース固有の処理を隠遮します。
　データベースハンドラーはモデルクラスのメソッドに必要なインタフェースを提供しデータベースとの
  直接的なデータの入出力を担当します。
  基底クラスのSQLでは十分な処理ができない場合、独自にSQLを生成して直接データベースドライバーの
  SQL実行メソッドを呼び出すことも可能ですが、そのときは AppModel のメソッドは使用しないでください。
  また AppHelper クラスも使用できなくなるので、同等のクラスを独自に実装してください。

  AppModel --+---- Handler
                    +-----> SQLite3
                    +-----> PostgreSQL
                    +-----> MySQL

2.2.1 テーブルスキーマ書式
  モデルクラスではデータベース接続のパラメータ定義とフィールドスキーマ定義で
  モデルクラスの動作を指定します。
  データベース接続のパラメータにはRDBMS名、テーブル名、プライマリーキーを定義します。
    'Handler'   => Null | Postgre | SQLite | MySQL
    'DataTable' => テーブル名 | [ 実テーブル名, ビュー名 ]
    'Primary'   => テーブルのプライマリーキー名
    'DataView'  => [
                    JOIN参照用ビュー名1
                    JOIN参照用ビュー名2
                    ...
                    ]
  DataTable を配列定義する場合は、複数のテーブルを使い生成したビューに書込みをしたいときです。
  通常マルチテーブルで生成したビューには書込ができないため、書込を行う実体テーブル名と参照用の
  ビューテーブル名を組み合わせた配列で指定します。実体のみの場合および更新の必要が無いときには
  配列にする必要はありません。
  DataView プロパティは他のモデルクラスで複数のリレーション定義(JOIN定義)により参照するときの
  エイリアスとして使用します。例えば、あるテーブルでカテゴリ1，カテゴリ2の２つのフィールドが
  カテゴリーモデルを参照しているときなどです。複数のJOIN定義がなければ定義する必要はありません。

  フィールドスキーマの定義は次のようにします。
  'Schema' => [
      フィールド名    => [ 表示用エイリアス名 ,　制御フラグ, 表示幅, JOIN定義, カラム連結 ],
      ...
  ]
  ※「表示幅」以降は省略可能です

  フィールド名：      データベーステーブルの列名です
  表示用エイリアス：  列名を別名でアクセスするためのエイリアスフィールド名です。不要なら空文字列にします。
  制御フラグ：        主にヘルパー基底クラスで使用します。10進数で桁ごとに用途が異なります。
                1位     0 = 非表示、1 = 表示・ソートなし、 2 = 表示・ソート可能
               10位     0 = なし、 1 = 左寄せ、 2 = 中央寄せ、 3 = 右寄せ
              100位     0 = ロケール無効、 1 = ロケール有効
                      ロケールフィールドは、デフォルトのフィールド名にアンダースコア＋ロケール名を付加した名前になります。
                      有効にするとロケール名の付加されたフィールドがR/W対象となります。
                      ただしテーブルにロケール名のついた列が定義されていないときは無効となります。
                      field::contents   =    0 → contents,  1 → contents_en (ロケールが en_US の時)
  表示幅              カラム表示幅を制御したいときに使用します(HeaderSchemaの4番目の要素に記憶される)
  JOIN定義            フィールド名にリレーションする「モデル名.カラム名.取得カラム名」を指定します
                      複数のカラムを取得する場合は「モデル名.カラム名」をキー名とする連想配列で定義する
                      ex. 'name_id' => ..., 'NameModel.id.fullName'
                      取得したカラムはフィールド名から[_id]を取り除いた要素名に代入されます。
                      取得カラム名を明治したいときや、複数のカラムを取得する場合は連想配列として定義します。
                      この場合は取得カラム名をアンダースコアで転結した要素名に代入されます。
                      ex. 'name_id' => ..., [ 'NameModel.id' => ['firstName','lastName'] ]
                          NameModel.firstName => name_firstName
                          NameModel.lastName  => name_lastName
                      取得先のフィールドが別のテーブルへのリレーションになっている場合は、
                      他のフィールドでも同じテーブルをJOIN定義してあると、エラーになります。
  カラム連結          複数のカラムを連結した仮想カラムを生成します。
                      ex. 'name_id' => ..., [ 'fullName' => ['firstName','lastName'] ]
                      firstName と lastName カラムを連結して fullName カラムを生成して代入します。

  セレクトタグのためのセレクションスキーマ定義は次のようになります。
  'Selection' => [
      セレクション名    => [ Modelキー => [ フィールドリスト ], [絞込み条件] ],   // ChainSelect()用の選択リスト
      セレクション名    => [ フィールドリスト, [絞込み条件] ],                    // ChainSelect()用の自モデルの選択リスト
      セレクション名    => [ Modelキー => フィールド名, [絞込み条件] ],          // [表示テキスト] = 選択値 のリスト
  ],
  フィールドリスト：　フィールド名のカンマリスト            [ 'id', 'name' , ... ]
  フィールド名：　フィールド名をピリオドで連結した文字列    'name.type'

  最初の２つはJQueryプラグインの ChainSelect() で使用するためのデータ配列を生成します。
  そのままでは参照できないため、ヘルパーの SelectObject() を呼出して、オブジェクト形式に変換して
  レイアウトに埋め込みます。
  3つ目の定義は簡易マークダウンや +selectコマンドのパラメータとしてそのまま使用できます。
  フィールド名を複数またはピリオドから始めるとセレクション名にフィールド名を付加した要素名に
  値を格納します。一つだけのときはセレクション名をそのまま使います。ひとつだけでもフィールド名を
  付加したいときは先頭にピリオドをつけてください。
  ex.     'table' => [ 'Table.id' => 'name'   ]         Select['table'] にnameの値リスト
          'table' => [ 'Table.id' => '.name'  ]         Select['table_name'] にnameの値リスト
  セレクションスキーマは値リストを全レコードを読み込んで取得するので、
  大容量のテーブルを参照するときは「必ず[絞り込み条件]を指定」するようにしてください。
  Modelキーの参照フィールドが、さらに別テーブルへJOIN定義されていた場合、JOIN先のの値を
  参照したい場合は、フィールドのJOIN別名を指定します。JOIN先ではなく単純にフィールド値を
  参照するときには、フィールド名を指定します。
  ex.   OsModel: スキーマ定義
          'family_id' => 'Family.id.name'
        PcModel: セレクション定義
          'os_id' => [ 'Os.id' => [ 'name', 'family' ] ]

        PcModel は os_id を元に OsModel の id に一致する nameフィールドと、
        さらにfamily_idに一致する FamilyModel の name フィールドを取得し、
        次のフィールド要素に代入されます。
          os_name
          os_family
        'family_id' を指定した場合、OsModelのフィールド値を格納します。

2.2.2  条件句の指定方法（SQL限定)
  モデルクラスの各メソッドで使用する、レコード検索における条件句には論理式が使用できます。
  論理式は連想配列で指定し、次のような形式になります。

    論理積   	AND => [ item, item,... ] | [ item, item,...]
    論理和   	OR  => [ item, item,... ]
    否定      NOT => [ item ]

  item の指定はカラム名に演算子を付加した連想配列です。
    比較カラム名＋演算子 => 比較値
    ex. 'status=" => '終了'
    使用できる演算子は次の通りです
      ＝  等しい
      <>  等しくない
      >=  以上
      <=  以下
      >   大きい
      <   小さい
      @   サブクエリ(※)
      %   LIKE演算指定

  比較値に配列を指定すると複数の値と比較することができます(IN ,NOT IN演算)
    ex.  'status=" => ['終了','完了','削除']

  比較演算子を指定しない場合、または明示的にLIKE演算子(%)を指定したときには LIKE 演算子が使用されます。
  演算子の指定がなく、比較値がピリオド３つで連結("XXXX...YYYY")されていた場合は BETWEEN 演算子が使われます。
    ex.  'period" => '2020/01/01...2021/01/01'
          → period BETWEEN ('2020/01/01' AND '2021/01/01')

  複数のカラムを同じ比較値で比較する場合、カラム名を＋記号で連結した記述ができます。
    ex.  'title+contents' => "Keyword"
    これは右の記述と同じです。    OR => [ 'title' => "Keyword",'contents' => "Keyword" ]

  ※ サブクエリ
    特殊演算子としてサブクエリ演算(@)を使用することができます。
    これはスキーマ定義でJOIN定義を行ったフィールドを使い、リレーション先のレコードを検索した結果をもとに絞り込む演算子です。
    ex. host_id でリレーションしているテーブルから、product_name カラムが "Windows" または "MacOS" のものだけを抽出する
        'host_id@' => [ 'product_name=' => ['Windws','MacOS' ] ]
        これは次のようにSQL展開されます
          WHERE host_id IN (SELECT host_table.id FROM host_table WHERE (host_table.product_name IN ('Windws','MacOS')))

　注意) サブクエリの条件に指定するフィールド名は言語設定によるカラム名置換(col_name → col_name_en)されません。
　　　　多言語指定したフィールド名をサブクエリに使う時には十分注意してください。

2.3 ビュー詳細
　ビュークラスはテンプレートの解析処理を行うクラスです。
  通常は基底クラスをそのまま使用しますが、モジュール固有のビュークラス(AppViewを継承)を生成することもできます。
  ただしテンプレート処理を阻害するようなメソッドの実装は避けてください。
　下位クラスにヘルパークラスを所有し、HTMLの自動生成や整形をプログラミングすることができます。
  画面表示にはビューテンプレートを使用します。テンプレートににはいくつか種類があります。詳しくは次節を参照してください。
　テンプレート内部でデータベースにアクセスする必要がある場合は、コントローラーから引き継いだモデルクラスを利用して
　アクセスすることができます。

■ 画面レイアウト定義
  View クラスは次の３種類のテンプレートファイルを組み合わせて構成します。

  template.php        PHPファイルによる画面出力
  template.inc        HTMLファイルによる画面出力
  template.tpl        セクション定義による画面出力
  template.mss        スタイルシート、javascriptの出力テンプレート

  .inc, .tplテンプレートではHTMLデータ以外に、フレームワーク内の変数が参照できます。
  フレームワーク変数には以下のものがあります。
  ・システム変数
      ${$SERVER$}      サーバー名
      ${$SYSROOT$}     フレームワークのトップURL
      ${$APPNAME$}     アプリケーション名
      ${$URIROOT$}     アプリケーションURLのトップ
      ${$URI$}         リクエストされたURI
      ${$REFERER$}     リファラー
      ${$controller$}  コントローラ名
      ${$method$}      メソッド名 (Actionを付加する前)
      ${$filter$}      フィルタ名、フィルタ配列の先頭値(${%a%}と同じ)
      ${%a%}～{%z%}    フィルタ配列パラメータ(0番目が %a%)
      ${%0%}～{%9%}    フィルタ配列以降の数値(文字列)パラメータ

  ・テンプレート変数
      ${変数名}       +setvar コマンドやテンプレート引数に与えられた変数
            例: +setvar => [
                  varnamse => values
                ]
              → ${varname}  =  "values"

  ・クラスプロパティ変数
      ${:ModelProp}         Modelクラスのプロパティ変数
      ${::HelpProp}         Helperクラスのプロパティ変数
      
      プロパティ変数が配列で特定要素を参照するときは「[キー名]」を付加します
      キー名は構造メンバー形式(xxx.yyy)で多次元配列を参照することもできます
        ${:Select[host_id]}       $Model->Select['host_id'] 要素を参照する
        ${:Select[host_id.name]}  $Model->Select['host_id']['name'] 要素を参照する

  ・レコード変数
      ${@フィールド名}      レコードデータのフィールド値、改行を<br>、HTML文字をエンティティ変換したもの
      ${@@フィールド名}     フィールド値の生データ

      レコード変数では指定フィールドの値が空または特定値のときに代替値を指定することが可能です。
        ${@フールド名=比較値!TRUE値:FALSE値}

      TRUE値、FALSE値の指定は @フィールド名 とすることで別のフィールド値を代替値に指定ができます。
      それ以外は文字列定数として返します。
      TRUE値、FALSE値はそれぞれ省略可能で、両方を省略したものが単純レコード変数です。
      比較値を省略したときにTRUE値が指定されていれば、フィールド値がFALSE値(NULL,0,f,false)かを判定し、
      TRUE値が省略されていれば、フィールド値が空かどうかで判定します。

        ${@ABC!正解:不正解}     @ABCがFALSE値(NULL,0,f,falseのいづれか)なら"不正解"を返し、それ以外は"正解"を返します
        ${@ABC:不正解}          @ABCが空値なら"不正解"を返し、空でなければ @ABCのフィールド値を返します

  ・レコード変数の翻訳
      ${#@フィールド名}     フィールド値をキーにして言語リソースから取得
                            言語リソースセクション名は Transfer に固定
                              ex. Transfer.フィールド値 => 'Transfer Lang'
  ・セッション変数
      ${'キー名'}        シングルクオートはセッション環境変数内のキー名で指定される値です
      ${"キー名"}        ダブルクオートはREQUEST変数内のキー名で指定される値
      ${^キー名^}        山記号は最初に環境変数を調べ、存在しなければREQUEST変数を調べます
      キー名は構造メンバー形式(xxx.yyy)で多次元配列を参照することもできます

  ・言語リソース変数
      ${#言語ID}        言語リソースの識別子(スカラー値)
      ${##言語ID}       スカラー値または配列値を取得

  ・ヘルパーメソッド変数
      ${&メソッド名}      ヘルパーメソッドを呼び出し、その戻り値を取得します
                          ヘルパーメソッドは文字列として値を返す必要があります
                          メソッドにはにはカッコを付加し文字列引数を渡すことができます
                          引数の指定が無い場合は「NULL」を引数として渡します
                          ${&help}      => $Helper->help(NULL);
                          ${&help(top)} => $Helper->help('top');

2.4 ヘルパー詳細
　ビューの従属クラスであり、テンプレートで処理できないプログラミングが必要になる処理を担当します。
　ヘルパーもコントローラーから継承したモデルクラスにアクセスできるプロパティ変数を持ちます。

2.5 テンプレート詳細

■ 共通セクションフォーマット
  画面レイアウト、スタイル・スクリプトファイルおよび言語ファイルは全てに共通の「セクション」フォーマットで記述します。
  これは PHP の連想配列の記述形式を応用したフォーマットになっています。

    キー名 => 値 or 配列

  各テンプレートでは「キー名」がタグやコマンド、識別子の役割を持ちます。
  改行を含む複数行テキストを定義するときはダブルクォートなどの特殊文字でくくります。
      "テキスト"          ダブルクォート 「'\n'」の改行文字は改行コード(\n)に置換する
      'テキスト'          シングルクォート
  クオート文字を両方含むテキストの場合は、次の代替え文字が使用できます。
      ~テキスト~          チルダ
      {テキスト}          中括弧
  テキストが複数行にわたる場合、行頭や行末のタブや空白はそのまま出力されますが、
  テキスト先頭にキャロット「^」を付けると、改行テキスト各の各行にトリミングをかけることができます。

  セクション内で指定するハイパーリンクは、次のような省略形が使用できます。
  ただし、省略形はテンプレートの各コマンド内のみで有効であり、href 属性などで
  直接記述している場合は無効となります。

  【ハイパーリンク省略形】
      http://～         URLの直接指定
      :xxx              http://(ホスト名)/xxx
      /xxx              /(フレームワークトップ)xxx～
      ./xxx             /(アプリトップ)/(モジュール名)/xxx
      xxx               /(アプリトップ)/xxx
      !!xxx             http://SERVER/xxx
      !:xxx             https://SERVER/xxx

■ 画面レイアウト テンプレート (*.tpl)
  セクションテンプレートの基本シンタックス次のようになっています。
    トークン => [
        キー名 => スカラー値
        スカラーテキスト
        トークン => [
          サブセクション
        ]
    ]
  トークンにはタグ項目とコマンド項目があり、それぞれで要素内の扱いは異なります。

  タグ項目のトークン場合、スカラー値を持つキー名はトークンの追加属性として扱われます。
  スカラーテキストは属性指定の書式のときにトークンの属性を記述することができます。
  書式は属性名と属性値をコロン(:)でつなげた文字列です。
    属性名：属性値  → style:"width:100%"
  属性書式に合致しないスカラーテキストはタグのインナーテキストとして出力します。
  書式に合致する場合でもインナーテキストとして出力したときはコロンの前にエスケープ文字を付加します。
      style\:"width:100%"
  または先頭に空白文字を付加するとインナーテキストとなります。
      ' style:"width:100%"'
  サブセクションはトークンの子要素として出力します。
  コマンド項目のトークンの場合は、コマンドへの引数として処理されるので、各々の要素については
  コマンド定義を参照してください。

  タグトークンはタグ名(省略可)に続けて、(.)クラス名、(#)ID名をキーとした配列要素となります。
  配列要素内には、さらに追加のタグ属性を記述できます。
  タグ名が省略された場合は「DIV」タグが指定されたものとみなします。
  追加属性は「属性名 => 属性値」の形式です。
  追加属性の中でも以下の特定属性についてはタグ項目に付加できる書式が定義してあります。
    size=NN             :NN
    name=xxxx           [xxxx]
    value=vvvv          (vvvv)
    data-element=yyyy   {yyyy}
  書式順は上記の上から順に記述してください。
  ex.
    span.right#menu[help](click){popup} => BUTTON
    => <SPAN class="right" id="menu" name="help" value="click" data-element="popup">BUTTON</span>

  コマンド項目のトークンにはタグ生成に関連するタグコマンドと、テンプレート関連のコマンドがあります。
  テンプレートコマンド
  @XXXXX  => [ key => Value ]             外部テンプレート呼び出し、配列は変数として引き渡し、連想配列にしなければ引数なしの呼び出し
                                          ドット(.)で始まる名前はまずインラインセクション名を参照し、未定義なら外部ファイルを参照する
  &FUNCS => [ key => value ]              Helperメソッド呼び出し、連想配列にすると引数として渡すが、スカラー定義の場合は引数なしの呼び出し

  $varname => VALUE                       サブセクション内だけで有効なローカル変数に値を代入します
  +setvar => [ varname => value , ...]    セクション内のグローバル変数を定義します。同名の変数があると置換されます
  
  タグコマンドは、HTMLタグの出力を簡略化するためのコマンドになっています。
  <HTML-TAG>                              HTMLタグとしてそのまま出力する
  *Comment                                コメントタグの出力
  -TAGS.XXXX#DDDD                         単独タグ、またはタグのリピート出力
  +include => [ value, ... ]              JS ファイル, CSS ファイルのインクルード
  +echo => [ value, ... ]                 value のリストをそのまま出力、キー名を指定しても無視する
  +style => [ value, ... ]                value のリストをスタイルシートとして出力する
  +jquery => [ value, ... ]               value のリストをJQuery関数として出力する
  +img => [ attr => value, src ]          imageタグの簡易出力書式, class,id以外の属性を指定しない場合はスカラー値で定義できる
                                          +img => src
  +ul/ol => [ attr => value , items ]     UL/OLタグ専用のリスト出力、スカラー要素をリスト項目として出力できる
      items :=                            リスト項目は次の要素から構成する
        list-item,                        スカラー要素：　単純リスト項目
        [ list-section ],           　    配列要素：　セクション項目
        .XXXX#DDDD => [ list-section ]    クラス名(XXXX)、ID名(DDDD)付のリストセクション項目
  +select => [                            SELECTタグ専用のリスト出力
    selected_key = > [                    連想キーは初期選択するアイテム名
      option_text => value                選択テキストと値のペアリスト
    ...   ]
  +table => [                             TABLEタグ専用の出力
      [                                   TR 配列, クラス/ID属性を使用可 (ex: .item#id => [ ... ] )
        th=>TEXT | [ TH-CELL ]            TH ヘッダセル, 要素を配列にするとセクションコマンドが使える
        .td_attr=>[ TD-CELL ] | [ TD-CELL ]  TD セル、キー名を指定するとクラス/ID属性を付加できる
      ] ... ]
  +radio => [ attr => value , items ]     INPUT RADIOタグ専用のリスト出力、スカラー要素をリスト項目として出力できる
      items :=                            リスト項目は次の要素から構成する
        checked-option-value =>           キー名と同じ値がデフォルト選択要素
          [ option => value ... ]         選択テキストと値のペアリスト
  +checkbox => [  check-items ]           チェックボックス、2つのフォーマットが使用可能
    FORMAT-I:                             単独のチェックボックスではname属性を指定する
      name=TEXT
      @Value => TEXT  [ STR => value ]    @Value=>TEXTはチェックされたときの値と表示文字、STRとvalue が等しいときはchecked
    FORMAT-II:                            複数のチェックボックスをまとめて出力するときはname属性をキーにした連想配列
      name1 => [ @value1=>TEXT [ STR1 => value1 ] ]
      name2 => [ @value2=>TEXT [ STR2 => value2 ] ]
  +dl => [ attr => value , [ items ]  ]   DLタグ専用のリスト出力、attr => value はDLタグの属性になる
    items :=                              リスト項目は次の要素から構成する
        inner-text,                       無名キースカラー要素：　DTタグのインナーテキスト
        attr => value,                    DTタグの属性
        [ list-section ],           　    無名キー配列要素：　DD要素のセクション項目
        .XXXX#DDDD => [ list-section ]    DD属性にクラス名(XXXX)、ID名(DDDD)を付けたセクション項目
  %link => [ link_str => href, ... ]      ハイパーリンク link_str に href のリンクを設定,Helper->ALinkを呼び出す
                                          単独タグの場合は省略形として以下の書式も使用できる
                                            %link_str => href
  +inline.SecName => [ ... ]              インラインのレイアウトセクション定義。テンプレート呼出しで再利用ができる
  +markdown => Text                       Text を簡易マークダウンとして整形したものを出力します。
                                          クラス属性を指定するとマークダウンのクラス名とします。
                                          Textが配列で渡された場合は、各要素を改行で結合したTextとして扱う
  +recordset => [ Section ]               読み込んだレコードごとに Section を繰返します
                                          name属性に：をつけるとモデルクラスのプロパティ変数で繰り返す
                                            ex. +recordset[:Outline] => [ Section ]
  +tabset => [                            ul タグを使ったタブセットの出力
    Title1 => [ Section ]                 テンプレート内の tabset.css を読み込むことでタブコントロール表示する
    ...                                   タブ切替え時に独自の処理が不要なら、テンプレートの tabset.js を読み込む
    ]
  +floatwin.class#id => [                 floatWindow ブロックの簡易記述構文
    DT-Title                              dl タグを直接記述せずにすむ
    [ DD-Section ]
  ]

  特定の変数やデータにより、タグ出力を切替えるにはスイッチセクション(?記号)を使います。
  スイッチセクション :=
    ?<判定値> => [
      ''  => [ Section ]        // <判定値> が空のときに Section を実行
      '*' => [ Section ]        // <判定値> に何か値が入っているときに Section を実行
      <比較値> => [ Section ]   // <判定値> が <比較値>と等しい時に Section を実行
    ]
  判定条件のどれにも一致しなかったときは何も実行されません。
  <比較値>にはシェルワイルドキャラクタ(?,*)の使用と、| による複数値の OR 比較が使えます。
  <判定値> を直接指定する代わりに、ヘルパーメソッドの呼び出しによるスイッチが使えます。
      ?&HelperMethod

  メソッドで処理することにより、複雑な条件でスイッチセクションを定義できるようになります。
  このヘルパーメソッドはセクションフォーマット配列を返す関数として作成してください。

  サブセクション内でスカラー値を持つ要素はタグ属性として処理されますが、スカラー要素を持つ場合でも
  セクション要素として処理したいときは、タグ名に空のクラス名('.'のみ)を付けます。
  
  .class => [
    style => "width:100%;"        // 通常のタグ属性
    style => [                    // 配列要素を持つが、タグ属性(style)として処理する
      "width:100%;"               // 配列要素はすべてを連結した文字列に変換される
      "height:100%;"
    ]
    style. => "width:100%;"       // 空のクラス名をつけるとタグトークンとして処理する
  ]

□ 簡易マークダウン記法
  本フレームワークではセクションテンプレートおよびAPIでマークダウンもどきの記法が利用できます。
  基本的な構文は一般的なマークダウン記法に準じていますが、テーブルやコード、フォーム部品など
  独自の拡張仕様になっているので、他システムとの互換性はありません。

  マークダウン変換したタグは <div class="easy_markdown">...</div> ブロック要素になります。
  クラス名を変更するには pseudo_markdown() 関数の第2引数にクラス名文字列を指定します。
  クラス名を変えたときには、独自にスタイル定義をしないと表示がくずれます。
  標準スタイルを使用する時は「markdown.css」をインポートします。

  マークダウンテキスト内にHTMLタグを埋め込むこともできます。
  マークダウンやHTMLタグ文字をエスケープする場合は。先頭にバックスラッシュ(\)を付加します。

  [テキスト](URL)             // ハイパーリンク
  ![ALTテキスト](URL)         // URLへの画像リンク
                              以下は独自仕様
                              URLの先頭文字に : または ! を付加すると特定のパスを指定できる
                              :　トップフォルダ
                              ! アプリトップフォルダ
                              ALTテキストの直後に：を続けると幅と高さを指定できる
                              ![ALTテキスト:幅,高さ](URL)

  --- | ___ | ***           // 水平線 <hr>
  # 見出し                  // 見出し1 <h1>
  ## 見出し                 // 見出し2 <h2>
  ### 見出し                // 見出し3 <h3>
  #### 見出し               // 見出し4 <h4>
  ##### 見出し              // 見出し5 <h5>
  ###### 見出し             // 見出し6 <h6>
  **強調**                  // 強調 (strong)
  __強調__                  // 強調 (em)
   *斜体*                   // 斜体 (font-style:italic)
  --取消線--                // 取消線 (del)
   _下線_                   // 下線 (text-decolration:underline)

  - アイテム1               // リスト(UL-LI)
  - アイテム2

  1. アイテム1              // 番号リスト(OL-LI)
  1. アイテム2

 > 引用                     // 引用 (blockquote)
 >> 引用ネスト

  行末の空白2個             // 改行 <br>
    または 全角空白1個

ここから以下は独自仕様のマークダウン構文です。

 |: ヘッダ標準 |:< ヘッダ左寄せ |:> ヘッダ右寄せ |:= ヘッダ中央 |   // テーブル(ヘッダ行:TH)
 | セル標準    |>  右寄せ       |<左寄せ         |=    中央     |   // セル(データ行:TD)
 .テーブルクラス名          // テーブルクラス(md_tbl)に追加するクラス名(省略可)

テーブルセルの属性文字の直後に＾、＠および．を続けると複数行列(rowspan/colspan)とクラス名の属性を付けられます。
また #数値 を指定すると style 属性で列幅(width)を指定できるので、わざわさ列幅指定のクラスをつくる手間を省けます。
|:.abc データ |             // THタグにクラス名 abc を漬けます
|=@@@ データ |              // TDタグを中央寄せにして３列分(@の数だけ)を連結(COLSPAN=3)します
|=^^^ データ |              // TDタグを中央寄せにして３行分(^の数だけ)を連結(ROWSPAN=3)します
|:=#80 データ |             // THタグを中央寄せにして列幅を 80px(style=width:80px;)にします。

  ..クラス名#ID{ テキスト } // クラス名、ID名を指定した SPAN タグ、クラス名、＃ID名は省略可能。前後に空白が必要。
                               テキストの { } の前に：をつけると P タグを使用します
                               ..abc:{テキスト}     =>   <p class="abc">テキスト</p>

  ...クラス名{              // div class=クラス名、クラス名を省略すると "indent" クラスになります
    テキスト                // テキスト内の改行を <br> タグに自動変換するには波括弧の前に ! を付けます。
  }...                      // ex.  ...!{ 改行テキスト } → 改行を <br> タグに自動変換

  ```クラス名               // pre class="クラス名"、クラス名を省略すると "code" クラスになります
  source-code
  ```
      クラス名は標準スタイルに「code, indent, quote」が定義済です。
      「```」の代わりに「~~~」または「^^^」が使用でき、その場合の省略クラス名は 'indent' です。
      'code'クラスが指定されたとき、source-codeのHTML特殊文字はエンティティ変換されHTMLタグが無効化されます。
      'indent', 'quote' その他のクラスの場合、HTMLタグが有効です。

  [チェック有無]{ラベル名}  // チェック有無が FALSE(空文字、0、f、false)であれば空白ブラケット
                            // それ以外なら [X] で表示する

  フォーム部品
  ^[name]@{checkval:item1=val1,item2=val2,,item3=val3}    // radio ボタン checkval=val の item にチェックをつける、空項目は改行(<br>)を挿入
  ^[name]:{item1=val1:checked}             // checkbox ボタン :checked が FALSE(0,NULL,'f','false')判定でなければチェックをつける
  ^[name]={textvalue:size}                 // text ボックス
  ^[name]!{textvalue:col,row}              // textarea
  ^[name]%{selectval:option1=val1,...}     // select
    item や textvalue に '}' が含まれるときはエスケープ '\}' します。
    textareaのインナーテキストは<BR>タグが除去され、その他のHTML特殊文字はエンティティ変換されます。

  定義リスト(DL)
  :タイトル(DT)
  本文(DD)
  \n\n                      // 連続した改行２個で終了


■ スタイル/スクリプト テンプレート (template.mss)
  テンプレートファイル名は固定ファイル名です。テンプレート内にはスタイル・スクリプトのセクションを定義します。
    Stylesheet => []                 スタイルシートのテンプレートセクション
    Javascript => []                 Javascriptのテンプレートセクション

  テンプレートファイルの探索は以下の順で行う
  モジュールフォルダ(modules/*/res/)         パスにモジュール名を含まない場合はスキップします
  → アプリ共通フォルダ(View/res/)
      → Libテンプレートフォルダ(Libs/Template/res/)

  テンプレート書式：
  // コメント行                         行末までコメントとして読み飛ばす、複数行のコメントは /*   */ で括る
  Section => [                          'Section' 名が拡張子を除いたファイル名として扱う
   *Comment                             * コメントタグ の出力
   @compact => on|off                   不要な空白を全て除去してコンパクト化する
   @comment => on|off                   コメント行のみを削除
   @message => on|off                   デバッグ用のコメントメッセージを抑制する
   @charset => XXXX                     文字セットを出力する
   +import => [ value, ... ]             CSS/JS ファイルのインクルード、スカラー値でも可
                                        テンプレートファイルと同レベルか上位レベルのフォルダで探索する
   +jquery => [ value, ... ]             JSファイルの時のみ、JQuery関数 ファイルのインクルード
                                        テンプレートファイルと同レベルか上位レベルのフォルダで探索する
   +section => subsection               別のセクション定義を読み込みます。セクション名の探索順は次のようになります
                                        (自ファイル内) → (アプリ共通フォルダ) → (フレームワークフォルダ)
                                        先頭に！文字を付けると (アプリ共通フォルダ) 以降の探索になり、
                                        ＾文字の場合はフレームワークフォルダを探索します
   tag => value                         タグの出力 => tag "value";
   tag => [ attr , ... ]                属性リストの出力 => tag { attr; ... }
  ]

  セクション外にあるコマンド(import/jquery/section/comment)はセクション指定にかかわらず処理します。
  ただし、最初に見つけたテンプレート内のみで section コマンドで呼び出したテンプレート内ではセクション外のコマンドは処理しません。
  全てのセクションファイルにセクション名が見つからなかった場合、実ファイル名を探索して見つけたファイルを出力します。
  インポートするファイルがひとつだけのセクション定義を不必要に増やさなくて済みます。

  URLにモジュール名を含めたときはモジュールフォルダ下のリソースから探索を始めます。
  アプリ共通リソースから探索するときはモジュール名を "res" とします。

    ex. index/css/mystyle.css   Indexモジュールの res フォルダ下にある template.mss ファイルから探索する
        res/css/common.css      アプリ共通フォルダ、またはLibテンプレートフォルダが対象

  CSSファイル名に「.min」を付加すると、ファイル内のコメントおよび改行・空白を削除したコンパクト形式で結合出力します。
  実ファイルの出力でも使用可。

    ex. res/css/style.css       ファイルの内容そのままで出力
        res/css/style.min.css   コメント行、改行・空白を削除しコンパクト化して出力する

  デバッグ中は[.min]をつけずにスタイルシートやスクリプトをテストし、完成したら「.min」を付けて運用します。
  (注)javascriptの場合、構文の最後(特に "}" 後)にセミコロンが無いとエラーとなるので必ずセミコロンを書く癖をつけること。

  import/jqueryコマンドでインポートされるファイル内では前述のシステム変数と以下のクラス変数を参照することができます。
    ${$appName$}         アプリ名
    ${$controller$}      モジュール名または 'Res'(共通リソース名)
    ${$filename$}        拡張子を除いたファイル名
    ${$extension$}       拡張子

  言語リソースの参照は、resource.lng ファイルとモジュール言語ファイルになります。
  アプリ共通パス(app/res/...)を指定した場合は resource.lng のみとなります。
    ${#言語ID}          リソース識別子

  またインポートするファイル名にクエリ文字列を付加することで環境変数として使用できます。
  このクエリ文字列はブラウザ上には表示されず、フレームワーク外からは操作できないので安全に使用できます。
    ex.  res/js/funcs.js?theme=green         ${theme} 変数として funcs.js 内で使用可能になる

  インポートファイル名にURIを指定するとインターネット上のファイルを読み込むことができます。
  URLの後ろにセミコロンに続けて「文字列1＝文字列2」という形式を付加すると、読み込んだ内容の「文字列１」を「文字列２」に置換します。
  それ以外のクラス変数やコメント削除などの置換処理は一切行いません。
    ex.  +import => http://www.hogehoge.com/js/jscript.js

  この設定はHTMLファイルに次のように記述したのと同じです。
    <script src='http://www.hogehoge.com/js/jscript.js'></script>

  この設定は外部サイトのファイルを「自分のサイトのファイル」のように動作するためライセンス違反を
  起こさないよう注意してください。
  また読み込んだ内容によってはXSS制限で正常に動作しないこともあるので、注意が必要です。
  ダウンロード使用が認められている場合は、ファイル名を同名にしたセクションを定義して
  その都度読み込ませる方法を取ります。
    ex.
      Javascript => [
        jscript => [
          +import => http://www.hogehoge.com/js/jscript.js
        ]
      ]
      →   <script src='/res/js/jscript.js'></script>

  インポートファイル名の先頭に「＠キーワード：」を付加すると、条件付きインポートになります。
  セッション変数に「キーワード」を持つ連想配列が定義されており、FALSE以外の値を持つときのみ
  指定のファイルを読み込むことができます。
  通常はセッション変数への登録はコントローラーの ClassInit() メソッド内で行います。
  ex.
    'admin' キーワードによりJQueryスクリプトの読込みを制御したいとき次のように設定します。
      MySession::set_paramIDs('admin',TRUE);
    スタイルリソースでは次のように参照します。
        jquery => [
          @admin:admintool.js
        ]
    例えば管理者以外のときにadmintool.jsを使わないようにしたければ、adminキーワードを設定しないか
    FALSE値を設定します。
    このセッション変数パラメータはコントローラーを呼び出すたびにリセットしており、
    連続して呼び出されるスタイル／スクリプトリソースとの間だけで共有されます。

  インポートする対象ファイルにはCSS/JS以外にPHPファイルを指定することができ、条件判断により
  複雑な出力の切り替えができるようになります。
  ただし、モジュールクラスのインスタンスを参照することはできないので、処理中のモジュール情報は
  セッション変数($EnvData['sysVAR'])から取得する必要があります。

■ 言語リソース テンプレート (*.lng)
  言語リソースは「モジュール名＋拡張子(lng)」で言語フォルダへ格納します。
  定義フォーマットはセクション定義と同じ形式になります。参照するときは識別子をピリオドで連結した文字列を指定します。
  相対参照が指示された時に、識別子が存在しなければ絶対参照を試みます。
    相対参照: .識別子1.識別子2
    絶対参照: 識別子1.識別子2

  例えば以下の定義の時に、モジュール内の相対参照「.識別子A.識別子B」は識別子Bが未定義のため、絶対参照「識別子A.識別子B」を参照します。
    識別子A => [
      識別子B => 絶対参照
    ]
    モジュール名 => [
      識別子A => [
        識別子C => 相対参照
      ]
    ]
  このルールを利用すると、絶対参照で定義された汎用識別名を、モジュール内で別の値にオーバーライドすることができます。
  テンプレートのファイル名はリソース名として言語リソースに格納されます。
  ファイル名先頭に「＃」を付けるとグローバルリソースとして登録します。
  また、モジュールリソース内でも識別名を「＃」で始めるとグローバル識別子として登録されます。
  起動時には「common.lng」ファイルがグローバル識別子を含むリソースとして読み込まれます。
  ※ファイル名「common」はモジュール名として使用しない。
  ex.1
  Lang.lng
    #GLOBAL => グローバル識別子       // 識別子は「GLOBAL」
    LOCAL => 識別子                   // 識別子はファイル名をモジュール名とした「Lang.LOCAL」
  ex.2
    #Lang.lng                         // Lang.lng で定義した識別名を全てグローバル識別子として登録
    #GLOBAL => グローバル識別子       // 識別子は「GLOBAL」
    LOCAL => 識別子                   // 識別子は「LOCAL」

  言語リソースはモジュール名をもとに読み込むようになっていて、最小限必要な定義ファイルのみを読み込みますが
  他のモジュールを利用する場合、別の言語リソースも必要になります。
  そのような場合には定義ファイル内でインポートコマンド「＠ファイル名」を記述しておきます。
  ex.
      // ツールバーの言語リソースをインポート
      @Toolbar

  ファイル同士で相互インポートになる場合は、先に読み込んだ方が有効リソースとなります。
  ただし、グローバル識別子のリソースは最後に読み込んだものが有効となる点がモジュールリソースとは異なります。

2.6 クラスメソッド詳細

  フレームワーク共通の静的クラスと、モジュール実装に必要な基底クラスに分類されます。
  静的クラスには、モジュールファイルの読み込みやディスパッチャをまとめた App クラス名、
  言語リソース用の LangUI クラスがあります。

2.6.1 静的クラス
　静的クラスはフレームワーク全体で共通の変数、処理を実装しています。
　モジュールクラスから任意に参照することができます。

◆ App クラス
・静的変数
  App::$SysVAR;                 // URIROOT, WEBROOT, URI, QUERY 変数
  App::$AppName;                // アプリケーション名
  App::$DocRoot;                // DOCUMENT_ROOT 変数
  App::$Referer;                // HTTP_REFERER
  App::$Query;                  // urlのクエリー文字列の連想配列
  App::$Filter;                 // メソッドのフィルタ指示
  App::$Filters;                // マルチフィルタのフィルタ配列
  App::$Params;                 // メソッドの数値パラメータ配列、または拡張子付きのファイル名
  App::$ParamCount;             // 引数の数
  App::$Controller;             // コントローラ名
  App::$Method;                 // メソッド名

・静的メソッド
  App::LoadModuleFiles(コントローラ名)   // appコントローラと付属モジュールファイルの読込
  App::Get_SysRoot(付加パス)             // フレームワークのトップパスに付加パスを付けた文字列
  App::Get_AppRoot(付加パス)             // アプリケーションのトップパスに付加パスを付けた文字列
  App::WebInclude(読込み配列)            //  css/js/icoファイルの読込タグ出力（単独）
  App::ImageSRC(ファイル名, 属性)        // imagesのインクルードタグ出力

◆ デバッガー関数
  デバッグメッセージはオンメモリに展開しているので、大量のメッセージ出力は避けてください。
  もしメモリ不足が発生するようなら、PHP.INIでメモリ容量を増やしてください。
  DEBUG_LEVEL                           // デバッガーの最大メッセージレベル
  DEBUGGER                              // デバッグメッセージバーの表示
  debug_run_start()                     // 実行時間測定
  debug_run_time(レベル)                // 実行時間のをレベルメッセージに追加
  debug_log(メッセージレベル,...出力要素) // 出力要素のログ出力
  get_debug_logs()                      // メッセージログの取得

◆ LangUI クラス
・静的変数
  LangUI::$STRINGS;                     // 翻訳言語配列
  LangUI::$LocaleName;                  // ロケール名

・静的メソッド
  LangUI::construct($lang)              // 言語リストを元にクラスを初期化する (Main.phpのみで使用)
  LangUI::LangFiles($files)             // モジュール言語ファイルを読み込む、$filesは配列可
  LangUI::get_value($mod, $id, $allow)  // モジュール内の言語識別名から文字列を取り出す、allow = TRUE なら配列を返す
  LangUI::get_array($arr, $mod, $var)   // 言語識別名から翻訳要素名を取り出し、連想配列の値を返す

◆ MySession クラス
・静的変数
  MySession::$EnvData;                  // セッションに記憶する環境変数
  MySession::$ReqData;                  // 環境変数とREQUEST されてきた変数(POST/GET)
  MySession::$MY_SESSION_ID;            // セッション変数内のアプリ固有キー

・静的メソッド
  MySession::InitSession()              // セッション変数を初期化する(Main.phpのみで使用)
  MySession::CloseSession()             // セッション変数を書き戻す(Main.phpのみで使用)
  MySession::preservReqData(...$keys)   // REQUEST変数から環境変数に移動する
  MySession::rollbackReqData(...$keys)  // SESSION変数からREQUESTに移動する
  MySession::getVariables($tt,...$arr)  // ENV(tt=TRUE) または REQ(tt=FALSE) 変数から値を取得した配列で返す
  MySession::setVariables($tt,$arr)     // ENV(tt=TRUE) または REQ(tt=FALSE) 変数に値をセット
  MySession::set_if_empty($tt,$arr)     // setVariables と同じだが、未定義キーだけを値セットする
  MySession::get_varIDs($tt,$names)     // ENV(tt=TRUE) または REQ(tt=FALSE) 変数から識別子指定で取得する
  MySession::rm_EnvData(...$arr)        // ENV変数をクリア

  MySession::get_LoginValue($id = NULL) // ログイン情報を取得
  MySession::set_LoginValue($arr)       // ログイン情報に書込
  MySession::setup_Login($login=NULL)   // ログイン情報を置換

◆ SendMail クラス（実験的）
・静的変数
  SendMail::$Header;                  // メールヘッダ
  SendMail::$From;                    // 差出人
  SendMail::$To;                      // 宛先
  SendMail::$CC;                      // 写し
  SendMail::$BCC;                     // ブラインドコピー
  SendMail::$Message;                 // メール本文
  SendMail::$Subject;                 // 件名

・静的メソッド
  SendMail::_Init()                   // static クラスにおける初期化処理(Main.phpのみで使用)
  SendMail::AppendMessage($msg)       // 本文にmsgを追加
  SendMail::SetFrom($username,$email) // 差出人を設定
  SendMail::AppendCC($email)          // 写しの宛先を追加
  SendMail::Send()                    // メール送信

2.6.2 動的クラス
  動的クラスはモジュール実装のための基底クラスになっています。
  コントローラーやビューの基本的なメソッドが実装されています。
  アプリケーションモジュールはこれらのクラスを継承することで、モジュール固有の処理に専念できます。
  基底クラスに実装されたメソッドをモジュール固有のものに置き換えたいときは、メソッドを再定義してください。
  ただし、基底クラスの他のメソッドに影響がでないように、整合性をとる必要があるメソッドもあるので要注意。

◆ 汎用クラス
  モジュールクラスの基底クラスとなるクラスや汎用的なクラスを定義してあります。

・祝日表クラス(CommonHolidays)
  祝日を計算するクラスです。
  このクラスを継承した、日本の祝日を定義している JapanHolidays クラスがあります。

・ログインクラス(LoginClass)
  LoginModel を実装するための基底クラス。AppModelから派生しています。
  このクラスではテーブルにユーザーID、パスワード、ユーザー言語の列が必要です。
    ユーザーID(任意)        // LoginID プロパティで指定できます
    'password'              // パスワード openssl_encrypt() で暗号化したもの
    'language'              // ユーザー言語(ja;en)

  ・クラスメソッド
    is_validUser($userid,$passwd) // ユーザデータを読み込んで検証する
    is_validLogin(POST変数)       // POSTされたログイン情報からユーザー情報を検証する

・ファイルフォルダークラス(FlatFolder)
  フォルダリストやファイルリストを管理するクラスです。
  このクラスにはZipファイルのダウンロード出力を行うメソッドが用意されています。

◆ モジュールクラス (* protectedメソッド：継承クラスのみで使用可)

・ベースクラス(AppObject)
  モジュールクラスの最上位クラスとなるオブジェクト管理のためのクラスです。
  MVCモデルに依存しないオブジェクトの管理クラスとなります。
  ・プロパティ変数
  *  $AOwner;                   // 所有オブジェクト
  *  $ClassType;                  // オブジェクトの所属クラス(Controller, Model, View, Helper)
  *  $ModuleName;                 // モジュールの名前
  *  $ClassName;                  // 自身のクラス名
  *  $LocalePrefix;               // 言語プレフィクス　初期値はモジュール名をセットする

  ・クラスメソッド
     ClassInit()                // サブクラスの初期化処理(サブクラス内でオーバーライド)
  *  setProperty($props)        // 連想配列によるクラスプロパティの初期化
  *  addSubclass($PropName)     // 動的クラスプロパティを生成

    _(識別名)                     // 言語ファイルから識別名で定義された文字列を取り出す
    _in(配列,識別名)              // 言語ファイルの識別子を元に連想配列から値を取り出す

・コントローラークラス(AppController)
  ・プロパティ変数
    $defaultAction                //  デフォルトのアクション
    $defaultFilter                //  デフォルトのフィルター
    $disableAction                // 禁止する継承元のアクション
	* $needLogin                    // ログイン要求の有無(デフォルト:FALSE)
  * $aliasAction                  // アクションメソッドの別名呼出し配列

  ・クラスメソッド
  * ActionPreProcess(action)      // アクション実行前に呼び出すメソッド、FALSEを返すとアクションをキャンセルします。
  * ActionPostProcess(action)     // アクション実行後に呼び出すメソッド
    SetHelperProps(array)         // ヘルパープロパティ変数のセット、テンプレートから参照できるようにする
    is_authorised()               // ログイン処理、$needLogin = FALSE なら常にTRUEを返す
    LogoutAction()                // セッション変数からログイン情報を削除
    AutoPaging($cond, $max_count) // Model クラスへのページング設定
    PagingFinder($cond,$max_count,$filter,$sort) // AutoPagingとRecordFinder()の連続呼び出し
    ListAction()                  // 標準処理：レコードリストの一覧表示
    PageAction()                  // 標準処理：ページング付きレコードリストの一覧表示
    FindAction()                  // 標準処理：検索
    ViewAction()                  // 標準処理：レコード表示
    AddAction()                   // 標準処理：レコード追加
    UpdateAction()                // 標準処理：レコード更新

    モジュールによっては標準処理の[find]や[page]メソッドを呼び出されては困る、という場合は
    $disableAction で呼出を禁止するアクションを配列で記述します。
    スカラー値を記述すると全てのアクションを禁止します。
    // ページングアクションを無効にする
    $disableAction = [ 'Page' ];     // 禁止するアクション

    リクエストURIによるメソッド呼出しは原則１対１で対応しますが、URIのメソッドとメソッド名が
    一致していないときや、複数のURIをひとつのメソッドで処理したい時などには別名呼出しを定義します。
    テンプレート変数には読替える前のメソッド名が格納されています。
      $aliasAction = [
          'List'    => 'ListItems',		// ListメソッドをListitemsメソッドに読替える
          'Viewall' => 'ListItems',		// ListallメソッドをListitemsメソッドに読替える
        ];

・モデルクラス(AppModel)
  ・プロパティ変数
    $DatabaseSchema             // クラス・プロパティ変数連想配列として定義する(static)
  * $dbDriver;                  // データベースドライバー
  * $fields;                    // レコードフィールドの値
    $pagesize;                  // ページャーの表示単位
    $page_num;                  // 表示するページ番号
    $record_max;                // 総レコード数
    $AliasMode;                 // 言語エイリアスモード TRUE=有効,FALSE=無効
    $RecData;                   // レコードデータ（JOINなし)
    $Select;                    // リレーション先の値リスト
    $Records;                   // 検索結果のレコードリスト(JOIN有)
    $HeaderSchema;              // $DatabaseSchema で定義したレコードヘッダー [ field_name => [disp_name, align, sort_flag, disp_width ]
    $DateFormat;                // 日付書式 YYYY-MM-DD, YYYY/MM/DD, ...
    $SortDefault;               // 検索時のソート順(デフォルト昇順)

  ・クラスメソッド
    SetPage($pagesize,$pagenum)               // ページング設定
    getRecordByKey($id)                       // PrimaryKey = $id のレコードを取得 $fields に格納しリターン値で返す
    getRecordBy($key,$value)                  // $key フィールドが $value のレコードを取得(JOIN無し) $fields に格納
    GetRecord($num,$join=FALSE)               // $num キーレコードデータを $fields, $RecData に格納、$join が TRUEならJOIN有効
    getRecordField($key,$value,$field)        // keyフィールドがvalueのレコードを検索しfield値を返す (JOIN無し)
    getCount($cond)                           // レコード数の検索
    GetFieldValues($field)                    // $field で指定された列の値リストを $Select 配列に格納
    GetValueList()                            // Selectionスキーマで定義された値リストを $Select 配列に格納
    RecordFinder($cond [,$filter [,$sort ]])  // レコードリストの読み込み(JOIN済レコード)
    RawRecordFinder($cond,$filte,$sort)       // RecordFinder() のJOIN無し版
    NearRecordFinder($id,$cond,$filter,$sort) // $sortで指定された並び順から、$idに一致するレコードとその前後のレコードを取得する
    DeleteRecord($num)                        // $num キーレコードの削除
    MultiDeleteRecord($cond)                  // 条件指定のレコード削除
    is_valid(&$row)                           // フィールドデータの検証、戻り値 TRUE=データ有効、FALSE=データ無効
    AddRecord($row)                           // レコード追加
    UpdateRecord($num,$row)                   // レコードの更新


・ビュークラス(AppView)
  ビュークラスはテンプレート処理へのI/Fを提供するクラスでサブクラスを定義する必要はありません、
  アプリ独自に拡張することができますが、その場合は基底クラスの処理を阻害しないようにしてください。
  ・プロパティ変数
  * $Layout;                    // レイアウトテンプレート名
    SetLayout($layoutfile)      // デフォルトレイアウト変更
    PutLayout()                 // レイアウト出力
    ViewTemplate($name)         // レイアウトテンプレート処理

・ヘルパークラス(AppHelper)
  ヘルパークラスにはプロパティ変数がありません。
  必要なら、setProperty(array)メソッドで動的にプロパティを定義します。

  ・クラスメソッド
    ViewTemplate($name)         // 親のViewクラスにあるテンプレート処理を呼び出す
    Resource ($res)             // リソースの出力
    ALink ($lnk,$txt)           // ハイパーリンクの生成, 言語IDを参照するには$txtを＃文字で始める
                                // $lnk を / で始めるとフレームワークのTOP、:で始めるとサイトのTOPへリンクする
    MakePageLinks()             // ページング用のリンクボタンを生成する
    MakeListTable ($deftab)     // ヘッダー付きのテーブルリスト表示、$deftabにはパラメータ
                                // $deftab['category'] = テーブルクラス
                                // $deftab['tableId']  = テーブルID 指定無しは "_TableList"
                                // $deftab['pager']    = ページャーナビを表示する
  * putTableHeader()            // テーブルヘッダーの出力(オーバーライドで変更可)
  * putColumnData($lno,$col)    // レコードカラムを出力(オーバーライドで変更可)
                                // $col 引数はフィールド名をクラス変数にセットしたクラスオブジェクト
    Tabset ($name,$menu,$sel)   // タブセットの生成 (UL版)
    TabContents ($sel)          // タブリストの生成 (UL版)
    Form ($act, $attr)          // フォームタグの生成
    Select ($key,$name)         // SELECTタグの生成
    Input ($type,$name,$attr)   // INPUTタグの生成
    ImageTag ($file,$attr)      // webrootファイルの読込
    SelectObject($keyset)       // ChainSelect()用のオブジェクトテーブルを生成する

・スタイルクラス(AppStyle)
  ※スタイルクラスは resource.php により処理されるので、継承することはできません。
    ViewHeader()                //　ContentType のヘッダ出力
    ViewStyle($filename)        //　レイアウトテンプレート処理

3. コントロール・ライブラリ

  Pawmooはアプリケーションの構築に役立つプリミティブなコントロールコンポーネントが
  テンプレートやリソースに組み込んであります。
  これらは「セクションフォーマット」とJavascript(JQuesry)ライブラリで提供されます。
  HTMLタグを直接記述すればセクション形式を使わなくてもすみますが、可読性が落ちるので
  可能な限りセクション形式を使用してください。

■ フローティング・ウィンドウ
  インナーウィンドウを表示します。ウィンドウの移動とリサイズが可能になっています。
  利用するには次のようなタグセクションを定義します。

    .floatWindow#＜要素ID＞ => [
      size => "幅,高さ,最小幅,最小高さ"　　　　// 指定しない場合はデフォルトサイズ
      data#init => [ value => ＜ウィンドウに表示する初期データ＞ ]  // Drag&Dropウィンドウの時に使う
      dl => [ dt => [ "ウィンドウのタイトル" ]
      dd => [
        div#datalist => [ ＜ダイアログに表示するデータ＞ ]
      ] ]
    ]

    このセクション定義には専用のセクションコマンドが用意されているので、専用コマンドを使うと
    dl タグを省略でき、ちょっとだけ記述を簡素化できます。

    +floatwin#＜要素ID＞ => [
      size => "幅,高さ,最小幅,最小高さ"　　　　// 指定しない場合はデフォルトサイズ
      data#init => [ value => ＜ウィンドウに表示する初期データ＞ ]
      "ウィンドウのタイトル"
      #datalist => [ ＜ダイアログに表示するセクションデータ＞ ]
    ]

  #init タグはウィンドウがドラッグ＆ドロップタイプの時に、初期状態のコンテンツ表示に使用します。
  通常のプロパティタイプのウィンドウにする場合は不要です。

■ バルーンヘルプ
  ポップアップするバルーンヘルプを表示します。
  バルーン表示のターゲットには「？」アイコンが自動的に付加されます。
  バルーン表示には、クリック式とマウスオーバー式が選べます。

    // バルーンヘルプ
    .popup-baloon{＜表示対象の要素ID＞} => [
      ＜テキスト＞
    ]

    表示対象となる要素IDの先頭に「！」文字を付加するとヘルプアイコンを付加しません。
    さらに「＠」文字を付加するとマウスオーバーによるポップアップバルーンになります。
    「＠」も付加しないときはクリックバルーンとなります。

■ ポップアップ・ウィンドウ
  指定要素からポップアップするインナーウィンドウを表示します。
  フローティング・ウィンドウとの違いは、ウィンドウの移動ができない点となります。

    .popup-box#＜要素ID＞{＜表示対象の要素ID＞} => [
      size => "幅,高さ,最小幅,最小高さ"　　　　// 指定しない場合はデフォルトサイズ
      .contents => [ ＜ウィンドウに表示するデータ＞ ]
    ]

■ コンテキストメニュー
  右クリックで表示されるポップアップメニューを定義します。
  メニューを実行する関数を定義したグローバル変数を一緒に定義しておく必要があります。
  コンテキストメニューは UL タグで定義します。

    // コンテキストメニュー
    +ul.context-menu#＜要素ID＞{＜メニュー表示対象の要素ID＞} => [
      ＜メニューID＞ => [ ＜メニュー文字列＞ ]
      [ ＜処理の無いメニュー＞ ]        // <hr> で区切り線を挿入する時など
      ...
    ]

    ポップアップメニューを処理するコールバック関数をグローバルオブジェクト
    popup_menu_function オブジェクトに登録します。

      var popup_menu_function = {
          "＜メニューID＞": (＜メニュー表示対象のJQueryオブジェクト＞) {
              // ここにメニュー実行の処理を記述する
          },
          ...
      };

■ stickyBar/fitWindowクラス
  stickyBarクラスは「position:sticky」のCSS が正しく動作しない(IE用)ときに指定します。
  このクラスを持つブロックは直前の fitWindow クラスブロックか親ブロックの位置に固定されます。

  fitWindowクラスはウィンドウの高さを親ウィンドウの幅と高さに合わせます。
  height:100%; の指定でスクロール領域がブラウザのウィンドウ外にはみ出てしまう現象を回避できます。

◆ ライブラリ関数
  コアシステムに組み込んである、アプリケーションから利用できるライブラリ関数一覧です。

・ファイル名関連
  extract_extension($filename)     $filename から拡張子を取り出す
  extract_base_name($ffilename)    返り値は array(ファイル名,拡張子)
  extract_path_file_ext($path)     返り値は array(パス,ファイル名,拡張子)
  extract_path_filename($path)     返り値は array(パス,ファイル名)
  file_move($src,$dest)            $src ファイルを $dest へ移動
  byte_format($size)               ファイルサイズを表す文字列を返す(KB,MB,GB)

・文字列操作
  str_fixwidth($exp,$pading,$width)    $exp を固定長に変換する
  strpos_of_array($str,$hayz)          $hayz 配列内に $str 文字列があるか
  text_to_html($atext)                 テキストをHTML文字列への変換
  json_escape($a)                      JSONで使用できる文字列に変換
  pseudo_markdown($atext)              簡易マークダウン
  get_protocol($href)                  先頭がプロトコルかどうか判定
  make_hyperlink($lnk,$modname)        ハイパーリンク生成
  mark_active_words($atext,$word,$class) span タグでのマーキング
  passwd_encrypt($str)                 OPENSSLを使った暗号化

・配列操作
  array_override($a, $b)                array_merge() の代替え、無名要素も上書きする
  text_line_array($del,$txt [,$trim])   テキストを配列に変換 $trimがTRUEなら空行削除
  array_to_text($array,$sep = "\n")     配列要素を改行テキストに変換
  array_member_value($array,$names)     構造化名(.)による多次元連想配列要素の参照

◆ Javascript関数
  Javascriptで使用できるプロトタイプ関数の一覧です。

・フレームワークのパス関連クラス
    Locations.query()                 クエリ文字列
    Locations.last_path()             パスの最後
    Locations.fw_fullpath()           http:// で始まるフルパス変換
    Locations.set_query(string)       クエリ文字列の設定
    Locations.href_controller(array)  コントローラーパス以降を配列値で置換したURL
    Locations.href_action(array)      アクションパス以降を配列値で置換したURL
    Locations.href_filter(array)      コントローラーパス以降を配列値で置換したURL
    Locations.href_param(array)       パラメータパス以降を配列値で置換したURL
    Locations.href_number(array)      数値パス以降を配列値で置換したURL

◆ JQueryプラグイン
  JQueryのプラグインとして使用できる関数

  ・スクロールを固定する
    (セレクタ).stickyOn(親オブジェクト);
  「stickyBar」クラスを付加したときと同じですが、動的読み込みしたコンテンツ内で使います。

  ・要素の幅・高さを最大値に調整します。
    (セレクタ).adjustWindow();          親要素の高さに調整する
  「fitWindow」クラスを付加したときと同じですが、動的読み込みしたコンテンツ内で使います。

  ・フローティングウィンドウを開く
    (セレクタ).floatWindow(タイトル, JSON, コールバック関数);

  ・Yes/No ボタン付きのダイアログボックスを開く
    $.dialogBox(タイトル,メッセージ, コールバック関数);

  ・プルダウンセレクトの連動
    (セレクタ).ChainSelect(セレクトテーブル,初期選択値)
      セレクトテーブルはチェインリストで定義します
        セレクト名: [
              [ ID,　表示名, 親ID ],
        ],
        ...
    トップレベルとなるセレクト名の親IDは省略、または0を入れておきます。
    ここで指定する「セレクト名」はSELECTタグにつけるCLASS名と同じ名前にします。
    例： OS名とライセンスキーを連動させるセレクトテーブル
      var objList = {
          'os-select': [
              [  1, "Windows"        ],   // レベル0
              [  2, "MacOS"  ],
              [  3, "Linux", ],
          ],
          'license-select': [
              [ 10, "Productkey-1", 1],   // レベル1
              [ 11, "Productkey-2", 1],
              [ 12, "Productkey-3", 2],
              [ 15, "MIT-License",  3],
          ]
      };
      $('#top-level').ChainSelect(objList,10);  // 初期値を '10' で初期化

      SELECTタグは次のように記述します。OPTION要素はセレクトテーブルから追加されるので記述不要です。
      
	        OS名:      <select class="os-select" id="top-level" name="os_id" data-ekenebt="next-level"></select>
	    プロダクトキー: <select class="license-select" id="next-level" name="license_id"></select>
